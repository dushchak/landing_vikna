/*eslint-disable */
/* Modernizr 2.8.3 (Custom Build) | MIT & BSD
 * Build: http://modernizr.com/download/#-cssanimations-shiv-cssclasses-prefixed-testprop-testallprops-domprefixes-load
 */
;window.Modernizr=function(a,b,c){function x(a){j.cssText=a}function y(a,b){return x(prefixes.join(a+";")+(b||""))}function z(a,b){return typeof a===b}function A(a,b){return!!~(""+a).indexOf(b)}function B(a,b){for(var d in a){var e=a[d];if(!A(e,"-")&&j[e]!==c)return b=="pfx"?e:!0}return!1}function C(a,b,d){for(var e in a){var f=b[a[e]];if(f!==c)return d===!1?a[e]:z(f,"function")?f.bind(d||b):f}return!1}function D(a,b,c){var d=a.charAt(0).toUpperCase()+a.slice(1),e=(a+" "+n.join(d+" ")+d).split(" ");return z(b,"string")||z(b,"undefined")?B(e,b):(e=(a+" "+o.join(d+" ")+d).split(" "),C(e,b,c))}var d="2.8.3",e={},f=!0,g=b.documentElement,h="modernizr",i=b.createElement(h),j=i.style,k,l={}.toString,m="Webkit Moz O ms",n=m.split(" "),o=m.toLowerCase().split(" "),p={},q={},r={},s=[],t=s.slice,u,v={}.hasOwnProperty,w;!z(v,"undefined")&&!z(v.call,"undefined")?w=function(a,b){return v.call(a,b)}:w=function(a,b){return b in a&&z(a.constructor.prototype[b],"undefined")},Function.prototype.bind||(Function.prototype.bind=function(b){var c=this;if(typeof c!="function")throw new TypeError;var d=t.call(arguments,1),e=function(){if(this instanceof e){var a=function(){};a.prototype=c.prototype;var f=new a,g=c.apply(f,d.concat(t.call(arguments)));return Object(g)===g?g:f}return c.apply(b,d.concat(t.call(arguments)))};return e}),p.cssanimations=function(){return D("animationName")};for(var E in p)w(p,E)&&(u=E.toLowerCase(),e[u]=p[E](),s.push((e[u]?"":"no-")+u));return e.addTest=function(a,b){if(typeof a=="object")for(var d in a)w(a,d)&&e.addTest(d,a[d]);else{a=a.toLowerCase();if(e[a]!==c)return e;b=typeof b=="function"?b():b,typeof f!="undefined"&&f&&(g.className+=" "+(b?"":"no-")+a),e[a]=b}return e},x(""),i=k=null,function(a,b){function l(a,b){var c=a.createElement("p"),d=a.getElementsByTagName("head")[0]||a.documentElement;return c.innerHTML="x<style>"+b+"</style>",d.insertBefore(c.lastChild,d.firstChild)}function m(){var a=s.elements;return typeof a=="string"?a.split(" "):a}function n(a){var b=j[a[h]];return b||(b={},i++,a[h]=i,j[i]=b),b}function o(a,c,d){c||(c=b);if(k)return c.createElement(a);d||(d=n(c));var g;return d.cache[a]?g=d.cache[a].cloneNode():f.test(a)?g=(d.cache[a]=d.createElem(a)).cloneNode():g=d.createElem(a),g.canHaveChildren&&!e.test(a)&&!g.tagUrn?d.frag.appendChild(g):g}function p(a,c){a||(a=b);if(k)return a.createDocumentFragment();c=c||n(a);var d=c.frag.cloneNode(),e=0,f=m(),g=f.length;for(;e<g;e++)d.createElement(f[e]);return d}function q(a,b){b.cache||(b.cache={},b.createElem=a.createElement,b.createFrag=a.createDocumentFragment,b.frag=b.createFrag()),a.createElement=function(c){return s.shivMethods?o(c,a,b):b.createElem(c)},a.createDocumentFragment=Function("h,f","return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&("+m().join().replace(/[\w\-]+/g,function(a){return b.createElem(a),b.frag.createElement(a),'c("'+a+'")'})+");return n}")(s,b.frag)}function r(a){a||(a=b);var c=n(a);return s.shivCSS&&!g&&!c.hasCSS&&(c.hasCSS=!!l(a,"article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}mark{background:#FF0;color:#000}template{display:none}")),k||q(a,c),a}var c="3.7.0",d=a.html5||{},e=/^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i,f=/^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i,g,h="_html5shiv",i=0,j={},k;(function(){try{var a=b.createElement("a");a.innerHTML="<xyz></xyz>",g="hidden"in a,k=a.childNodes.length==1||function(){b.createElement("a");var a=b.createDocumentFragment();return typeof a.cloneNode=="undefined"||typeof a.createDocumentFragment=="undefined"||typeof a.createElement=="undefined"}()}catch(c){g=!0,k=!0}})();var s={elements:d.elements||"abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video",version:c,shivCSS:d.shivCSS!==!1,supportsUnknownElements:k,shivMethods:d.shivMethods!==!1,type:"default",shivDocument:r,createElement:o,createDocumentFragment:p};a.html5=s,r(b)}(this,b),e._version=d,e._domPrefixes=o,e._cssomPrefixes=n,e.testProp=function(a){return B([a])},e.testAllProps=D,e.prefixed=function(a,b,c){return b?D(a,b,c):D(a,"pfx")},g.className=g.className.replace(/(^|\s)no-js(\s|$)/,"$1$2")+(f?" js "+s.join(" "):""),e}(this,this.document),function(a,b,c){function d(a){return"[object Function]"==o.call(a)}function e(a){return"string"==typeof a}function f(){}function g(a){return!a||"loaded"==a||"complete"==a||"uninitialized"==a}function h(){var a=p.shift();q=1,a?a.t?m(function(){("c"==a.t?B.injectCss:B.injectJs)(a.s,0,a.a,a.x,a.e,1)},0):(a(),h()):q=0}function i(a,c,d,e,f,i,j){function k(b){if(!o&&g(l.readyState)&&(u.r=o=1,!q&&h(),l.onload=l.onreadystatechange=null,b)){"img"!=a&&m(function(){t.removeChild(l)},50);for(var d in y[c])y[c].hasOwnProperty(d)&&y[c][d].onload()}}var j=j||B.errorTimeout,l=b.createElement(a),o=0,r=0,u={t:d,s:c,e:f,a:i,x:j};1===y[c]&&(r=1,y[c]=[]),"object"==a?l.data=c:(l.src=c,l.type=a),l.width=l.height="0",l.onerror=l.onload=l.onreadystatechange=function(){k.call(this,r)},p.splice(e,0,u),"img"!=a&&(r||2===y[c]?(t.insertBefore(l,s?null:n),m(k,j)):y[c].push(l))}function j(a,b,c,d,f){return q=0,b=b||"j",e(a)?i("c"==b?v:u,a,b,this.i++,c,d,f):(p.splice(this.i++,0,a),1==p.length&&h()),this}function k(){var a=B;return a.loader={load:j,i:0},a}var l=b.documentElement,m=a.setTimeout,n=b.getElementsByTagName("script")[0],o={}.toString,p=[],q=0,r="MozAppearance"in l.style,s=r&&!!b.createRange().compareNode,t=s?l:n.parentNode,l=a.opera&&"[object Opera]"==o.call(a.opera),l=!!b.attachEvent&&!l,u=r?"object":l?"script":"img",v=l?"script":u,w=Array.isArray||function(a){return"[object Array]"==o.call(a)},x=[],y={},z={timeout:function(a,b){return b.length&&(a.timeout=b[0]),a}},A,B;B=function(a){function b(a){var a=a.split("!"),b=x.length,c=a.pop(),d=a.length,c={url:c,origUrl:c,prefixes:a},e,f,g;for(f=0;f<d;f++)g=a[f].split("="),(e=z[g.shift()])&&(c=e(c,g));for(f=0;f<b;f++)c=x[f](c);return c}function g(a,e,f,g,h){var i=b(a),j=i.autoCallback;i.url.split(".").pop().split("?").shift(),i.bypass||(e&&(e=d(e)?e:e[a]||e[g]||e[a.split("/").pop().split("?")[0]]),i.instead?i.instead(a,e,f,g,h):(y[i.url]?i.noexec=!0:y[i.url]=1,f.load(i.url,i.forceCSS||!i.forceJS&&"css"==i.url.split(".").pop().split("?").shift()?"c":c,i.noexec,i.attrs,i.timeout),(d(e)||d(j))&&f.load(function(){k(),e&&e(i.origUrl,h,g),j&&j(i.origUrl,h,g),y[i.url]=2})))}function h(a,b){function c(a,c){if(a){if(e(a))c||(j=function(){var a=[].slice.call(arguments);k.apply(this,a),l()}),g(a,j,b,0,h);else if(Object(a)===a)for(n in m=function(){var b=0,c;for(c in a)a.hasOwnProperty(c)&&b++;return b}(),a)a.hasOwnProperty(n)&&(!c&&!--m&&(d(j)?j=function(){var a=[].slice.call(arguments);k.apply(this,a),l()}:j[n]=function(a){return function(){var b=[].slice.call(arguments);a&&a.apply(this,b),l()}}(k[n])),g(a[n],j,b,n,h))}else!c&&l()}var h=!!a.test,i=a.load||a.both,j=a.callback||f,k=j,l=a.complete||f,m,n;c(h?a.yep:a.nope,!!i),i&&c(i)}var i,j,l=this.yepnope.loader;if(e(a))g(a,0,l,0);else if(w(a))for(i=0;i<a.length;i++)j=a[i],e(j)?g(j,0,l,0):w(j)?B(j):Object(j)===j&&h(j,l);else Object(a)===a&&h(a,l)},B.addPrefix=function(a,b){z[a]=b},B.addFilter=function(a){x.push(a)},B.errorTimeout=1e4,null==b.readyState&&b.addEventListener&&(b.readyState="loading",b.addEventListener("DOMContentLoaded",A=function(){b.removeEventListener("DOMContentLoaded",A,0),b.readyState="complete"},0)),a.yepnope=k(),a.yepnope.executeStack=h,a.yepnope.injectJs=function(a,c,d,e,i,j){var k=b.createElement("script"),l,o,e=e||B.errorTimeout;k.src=a;for(o in d)k.setAttribute(o,d[o]);c=j?h:c||f,k.onreadystatechange=k.onload=function(){!l&&g(k.readyState)&&(l=1,c(),k.onload=k.onreadystatechange=null)},m(function(){l||(l=1,c(1))},e),i?k.onload():n.parentNode.insertBefore(k,n)},a.yepnope.injectCss=function(a,c,d,e,g,i){var e=b.createElement("link"),j,c=i?h:c||f;e.href=a,e.rel="stylesheet",e.type="text/css";for(j in d)e.setAttribute(j,d[j]);g||(n.parentNode.insertBefore(e,n),m(c,0))}}(this,document),Modernizr.load=function(){yepnope.apply(window,[].slice.call(arguments,0))};
/*eslint-enable */

/*eslint-disable */
(function (window) {

    'use strict';

    var support = {animations: Modernizr.cssanimations},
        animEndEventNames = {
            'WebkitAnimation': 'webkitAnimationEnd',
            'OAnimation': 'oAnimationEnd',
            'msAnimation': 'MSAnimationEnd',
            'animation': 'animationend'
        },
        animEndEventName = animEndEventNames[Modernizr.prefixed('animation')],
        onEndAnimation = function (el, callback) {
            var onEndCallbackFn = function (ev) {
                if (support.animations) {
                    if (ev.target != this) return;
                    this.removeEventListener(animEndEventName, onEndCallbackFn);
                }
                if (callback && typeof callback === 'function') {
                    callback.call();
                }
            };
            if (support.animations) {
                el.addEventListener(animEndEventName, onEndCallbackFn);
            }
            else {
                onEndCallbackFn();
            }
        };

    function extend(a, b) {
        for (var key in b) {
            if (b.hasOwnProperty(key)) {
                a[key] = b[key];
            }
        }
        return a;
    }

    function DialogFx(el, options) {
        this.el = el;
        this.options = extend({}, this.options);
        extend(this.options, options);
        this.isOpen = false;
        this._initEvents();
    }

    DialogFx.prototype.options = {
        // callbacks
        onOpenDialog: function () {
            return false;
        },
        onCloseDialog: function () {
            return false;
        },
        onOpenAnimationEnd: function () {
            return false;
        },
        onCloseAnimationEnd: function () {
            return false;
        }
    };

    DialogFx.prototype._initEvents = function () {
        var self = this;

        // esc key closes dialog
        document.addEventListener('keydown', function (ev) {
            var keyCode = ev.keyCode || ev.which;
            if (keyCode === 27 && self.isOpen) {
                self.toggle();
            }
        });

        if(this.el.classList.contains('mistape-glossary')) {
          var btn = this.el.querySelector('.mistape-button-close');
          btn.addEventListener('click', this.toggle.bind(this));
        }
        this.el.querySelector('.dialog__overlay').addEventListener('click', this.toggle.bind(this));
    };

    DialogFx.prototype.toggle = function () {
        var self = this;
        if (this.isOpen) {
            jQuery(this.el).removeClass('dialog--open');
            jQuery(self.el).addClass('dialog--close');

            onEndAnimation(this.el.querySelector('.dialog__content'), function () {
                jQuery(self.el).removeClass('dialog--close');
                self.options.onCloseAnimationEnd(self);
            });

            // callback on close
            this.options.onCloseDialog(this);
        }
        else {
            jQuery(this.el).addClass('dialog--open');

            // callback on open
            this.options.onOpenDialog(this);

            onEndAnimation(this.el.querySelector('.dialog__content'), function () {
                jQuery(self.el).removeClass('dialog--close');
                self.options.onOpenAnimationEnd(self);
            });
        }
        this.isOpen = !this.isOpen;
    };

    // add to global namespace
    window.DialogFx = DialogFx;

})(window);


/**
 * Mistape
 */
(function ($) {

    // return if no args passed from backend
    if (!window.decoMistape) {
        return;
    }

    window.decoMistape = $.extend(window.decoMistape, {

        onReady: function () {
            decoMistape.initDialogFx();

            var $dialog = $(decoMistape.dlg.el);

            $(document).on('click', '.mistape_action', function () {
                if ($(this).is('[data-action=send]')) {
                    var data;
                  var isGlossary = $(this).closest('.mistape-glossary');
                    if (!$dialog.data('dry-run') && (data = $dialog.data('report'))) {
                        if ($dialog.data('mode') === 'comment') {
                            data.comment = $dialog.find('#mistape_comment').val();
                            $('#mistape_comment').val('');
                        }
                        data.post_id = $(this).data('id');
                        if(isGlossary.length) {
                          var changesTextarea = isGlossary.find('#changes');
                          var inputWrapper = isGlossary.find('.mistape-textarea-wrap');
                          var value = changesTextarea.val();
                          var error = '<span class="input-txt__error-text-ppc">Заполните поле</span>';
                          if(!value.length) {
                            inputWrapper.append(error);
                            changesTextarea.addClass('error');
                          } else {
                            isGlossary.find('.input-txt__error-text-ppc').remove();
                            changesTextarea.removeClass('error');
                            data.changes = value;
                            decoMistape.reportSpellError(data);
                            changesTextarea.val('');
                            decoMistape.animateLetter();
                          }
                        } else {
                          decoMistape.reportSpellError(data);
                        }

                    }
                  if(!isGlossary.length) {
                    decoMistape.animateLetter();
                  }
                }
                else if ($(this).is('[data-dialog-close]')) {
                    decoMistape.dlg.toggle();
                }
            });

            $(document).keyup(function (ev) {
                if (ev.keyCode === 13 && ev.ctrlKey && ev.target.nodeName.toLowerCase() !== 'textarea' && $('#mistape_dialog.dialog--open').length === 0) {
                    var report = decoMistape.getSelectionData();
                    if (report) {
                        decoMistape.showDialog(report);
                    }
                }
            });
        },

        initDialogFx: function () {
            decoMistape.dlg = new DialogFx(document.getElementById('mistape_dialog'), {
                onOpenDialog: function (dialog) {
                    $(dialog.el).css('display', 'flex');
                    $(dialog.el).find('.mistape-letter-top').removeClass('mistape-close');

                },
                onCloseAnimationEnd: function (dialog) {
                    $(dialog.el).css('display', 'none');
                    decoMistape.resetDialog();
                }
            });
        },

        animateLetter: function () {
            var dialog = $(decoMistape.dlg.el),
                content = dialog.find('.dialog__content'),
                letterTop = dialog.find('.mistape-letter-top'),
                letterFront = dialog.find('.mistape-letter-front'),
                letterBack = dialog.find('.mistape-letter-back'),
                dialogWrap = dialog.find('.dialog-wrap');

            content.addClass('show-letter');

            setTimeout(function () {
                var y = (letterTop.offset().top - letterFront.offset().top) + letterTop.outerHeight();

                letterTop.css({
                    'bottom': Math.floor(y),
                    'opacity': 1
                });
                jQuery('.mistape-letter-back-top').hide();
                if (content.hasClass('with-comment')) {
                    dialogWrap.css('transform', 'scaleY(0.5) scaleX(0.28)');
                } else {
                    dialogWrap.css('transform', 'scaleY(0.5) scaleX(0.4)');
                }
                setTimeout(function () {
                    if (content.hasClass('with-comment')) {
                        dialogWrap.css('transform', 'translateY(12%) scaleY(0.5) scaleX(0.4)');
                    } else {
                      if(dialogWrap.closest('.mistape-glossary').length) {
                        dialogWrap.css('transform', 'translateY(-13%) scaleY(0.3) scaleX(0.45)');
                      } else {
                        dialogWrap.css('transform', 'translateY(-13%) scaleY(0.5) scaleX(0.45)');
                      }
                    }
                    setTimeout(function () {
                        letterTop.css('z-index', '9');
                        letterTop.addClass('mistape-close');
                        setTimeout(function () {
                            dialogWrap.css({
                                'visibility': 'hidden',
                                'opacity': '0'
                            });
                            letterFront.css('animation', 'send-letter1 0.7s');
                            letterBack.css('animation', 'send-letter1 0.7s');
                            letterTop.css('animation', 'send-letter2 0.7s');
                            setTimeout(function () {
                                decoMistape.dlg.toggle();
                                letterTop.css({
                                  'z-index': '2'
                                });
                            }, 400)
                        }, 400)
                    }, 400)
                }, 300)
            }, 400);
        },

        showDialog: function (report) {
            if (report.hasOwnProperty('selection') && report.hasOwnProperty('context')) {
                var $dialog = $(decoMistape.dlg.el);

                if ($dialog.data('mode') == 'notify') {
                    decoMistape.reportSpellError(report);
                    decoMistape.dlg.toggle();
                }
                else {
                    $dialog.data('report', report);
                    $dialog.find('#mistape_reported_text').html(report.preview_text);
                    decoMistape.dlg.toggle();
                }
            }
        },

        resetDialog: function () {
            var $dialog = $(decoMistape.dlg.el);

            if ($dialog.data('mode') != 'notify') {
                $dialog.find('#mistape_confirm_dialog').css('display', '');
                $dialog.find('#mistape_success_dialog').remove();
            }

            // letter
            $dialog.find('.dialog__content').removeClass('show-letter');
            $dialog.find('.mistape-letter-top, .mistape-letter-front, .mistape-letter-back, .dialog-wrap, .mistape-letter-back-top').removeAttr('style');
            $dialog.find('.mistape-letter-top').removeClass('close');
        },

        reportSpellError: function (data) {
            data.action = 'mistape_report_error';
            $.ajax({
                type: 'post',
                dataType: 'json',
                url: decoMistape.ajaxurl,
                data: data
            })
        },

        getSelectionData: function () {
            // Check for existence of window.getSelection()
            if (!window.getSelection) {
                return false;
            }

            var parentEl, sel, selChars, selWord, textToHighlight, maxContextLength = 140;

            var stringifyContent = function (string) {
                return typeof string == 'string' ? string.replace(/\s*(?:(?:\r\n)+|\r+|\n+)\t*/gm, '\r\n').replace(/\s{2,}/gm, ' ') : '';
            };

            var isSubstrUnique = function (substr, context) {
                if (typeof context === 'undefined') {
                    context = decoMistape.contextBuffer;
                }
                if (typeof substr === 'undefined') {
                    substr = decoMistape.selBuffer;
                }
                var split = context.split(substr);
                var count = split.length - 1;
                return count === 1;

            };

            var getExactSelPos = function (selection, context) {
                // if there is only one match, that's it
                if (isSubstrUnique(selWithContext, context)) {
                    return context.indexOf(selWithContext);
                }
                // check if we can get the occurrence match from selection offsets
                if (!backwards) {
                    // check anchor element
                    if (context.substring(sel.anchorOffset, sel.anchorOffset + selection.length) == selection) {
                        return sel.anchorOffset;
                    }
                    // check anchor parent element
                    var parentElOffset = sel.anchorOffset;
                    var prevEl = sel.anchorNode.previousSibling;
                    while (prevEl !== null) {
                        parentElOffset += prevEl.textContent.length;
                        prevEl = prevEl.previousSibling;
                    }
                    if (context.substring(parentElOffset, parentElOffset + selection.length) == selection) {
                        return parentElOffset;
                    }
                }
                if (backwards && context.substring(sel.focusOffset, sel.focusOffset + selection.length) == selection) {
                    return sel.anchorOffset;
                }
                return -1;
            };

            var getExtendedSelection = function (limit, nodeExtensions) {

                limit = parseInt(limit) || 40;
                nodeExtensions = nodeExtensions || {left: '', right: ''};
                var i = 0, selContent, selEndNode = sel.focusNode, selEndOffset = sel.focusOffset;

                while (i <= limit) {

                    if ((selContent = stringifyContent(sel.toString().trim())).length >= maxContextLength || isSubstrUnique(selContent, context)) {
                        return selContent;
                    }

                    // only even iteration
                    if (i % 2 == 0 && sel.anchorOffset > 0 || nodeExtensions.left.length && i < limit / 2) {
                        // reset
                        if (backwards) {
                            sel.collapseToEnd();
                        }
                        else {
                            sel.collapseToStart();
                        }
                        sel.modify("move", direction[1], "character");
                        sel.extend(selEndNode, selEndOffset);
                    }
                    else if (sel.focusOffset < sel.focusNode.length || nodeExtensions.right.length && i < limit / 2) {
                        sel.modify('extend', direction[0], 'character');
                        if (sel.focusOffset === 1) {
                            selEndNode = sel.focusNode;
                            selEndOffset = sel.focusOffset;
                        }
                    }
                    else if (i % 2 == 0) {
                        break;
                    }

                    i++;
                }

                return stringifyContent(sel.toString().trim());
            };

            var getExtendedContext = function (context, element, method) {
                var contentPrepend = '', contentAppend = '', e = element, i;
                method = method || 'textContent';

                for (i = 0; i < 20; i++) {
                    if (contentPrepend || (e = e.previousSibling) === null) {
                        break;
                    }

                    if ((contentPrepend = stringifyContent(e[method].trim())).length) {
                        context = contentPrepend + context;

                    }
                }

                // reset element
                e = element;

                for (i = 0; i < 20; i++) {
                    if (contentAppend || (e = e.nextSibling) === null) {
                        break;
                    }
                    if ((contentAppend = stringifyContent(e[method]).trim()).length) {
                        context += contentAppend;
                    }
                    else if (context.slice(-1) != ' ') {
                        context += ' ';
                    }
                }

                return {
                    contents: context,
                    extensions: {
                        left: contentPrepend,
                        right: contentAppend
                    }
                };
            };

            // check that getSelection() has a modify() method. IE has both selection APIs but no modify() method.
            // this works on modern browsers following standards
            if ((sel = window.getSelection()).modify) {
                // check if there is any text selected
                if (!sel.isCollapsed) {

                    /**
                     * So the first step is to get selection extended to the boundaries of words
                     *
                     * e.g. if the sentence is "What a wonderful life!" and selection is "rful li",
                     * we get "wonderful life" stored in selWord variable
                     */

                    selChars = sel.toString();

                    // return early if no selection to work with or if its length exceeds the limit
                    if (!selChars || selChars.length > maxContextLength) {
                        return;
                    }

                    // here we get the nearest parent node which is common for the whole selection
                    if (sel.rangeCount) {
                        parentEl = sel.getRangeAt(0).commonAncestorContainer.parentNode;
                        while (parentEl.textContent == sel.toString()) {
                            parentEl = parentEl.parentNode;
                        }
                    }

                    // Detect if selection was made backwards
                    // further logic depends on it
                    var range = document.createRange();
                    range.setStart(sel.anchorNode, sel.anchorOffset);
                    range.setEnd(sel.focusNode, sel.focusOffset);
                    var backwards = range.collapsed;
                    range = null;

                    // save initial selection to restore in the end
                    var initialSel = {
                        focusNode: sel.focusNode,
                        focusOffset: sel.focusOffset,
                        anchorNode: sel.anchorNode,
                        anchorOffset: sel.anchorOffset
                    };

                    // modify() works on the focus of the selection (not virtually) so we manipulate it
                    var endNode = sel.focusNode, endOffset = sel.focusOffset;

                    // determine second char of selection and the one before last
                    // they will be our starting point for word boundaries detection
                    var direction, secondChar, oneBeforeLastChar;
                    if (backwards) {
                        direction = ['backward', 'forward'];
                        secondChar = selChars.charAt(selChars.length - 1);
                        oneBeforeLastChar = selChars.charAt(0);
                    } else {
                        direction = ['forward', 'backward'];
                        secondChar = selChars.charAt(0);
                        oneBeforeLastChar = selChars.charAt(selChars.length - 1);
                    }

                    // collapse the cursor to the first char
                    sel.collapse(sel.anchorNode, sel.anchorOffset);
                    // move it one char forward
                    sel.modify("move", direction[0], "character");

                    // if the second character was a letter or digit, move cursor another step further
                    // this way we are certain that we are in the middle of the word
                    if (null === secondChar.match(/'[\w\d]'/)) {
                        sel.modify("move", direction[0], "character");
                    }

                    // and now we can determine the beginning position of the word
                    sel.modify("move", direction[1], "word");

                    // then extend the selection up to the initial point
                    // thus assure that selection starts with the beginning of the word
                    sel.extend(endNode, endOffset);

                    // do the same trick with the ending--extending it precisely up to the end of the word
                    sel.modify("extend", direction[1], "character");
                    if (null === oneBeforeLastChar.match(/'[\w\d]'/)) {
                        sel.modify("extend", direction[1], "character");
                    }
                    sel.modify("extend", direction[0], "word");
                    if (!backwards && sel.focusOffset === 1) {
                        sel.modify("extend", 'backward', "character");
                    }

                    // since different browser extend by "word" differently and some of them extend beyond the word
                    // covering spaces and punctuation, we need to collapse the selection back so it ends with the word
                    var i = 0, lengthBefore, lengthAfter;
                    while (i < 5 && (sel.toString().slice(-1).match(/[\s\n\t]/) || '').length) {
                        lengthBefore = sel.toString().length;
                        if (backwards) {
                            endNode = sel.anchorOffset == 0 ? sel.anchorNode.previousSibling : sel.anchorNode;
                            endOffset = sel.anchorOffset == 0 ? sel.anchorNode.previousSibling.length : sel.anchorOffset;
                            sel.modify('move', 'backward', 'character');
                            sel.extend(endNode, endOffset);
                            backwards = false;
                            direction = ['forward', 'backward'];
                        } else {
                            sel.modify('extend', 'backward', 'character');
                        }
                        lengthAfter = sel.toString().length;

                        // workaround for WebKit quirk: undo last iteration
                        if (lengthBefore - lengthAfter > 1) {
                            sel.modify('extend', 'forward', 'character');
                            break;
                        }
                    }

                    // finally, we've got a modified selection which is bound to words
                    // save it to highlight it later
                    selWord = stringifyContent(sel.toString().trim());
                }
            }
            // this one is for IE11
            else if (sel = window.getSelection()) {
                var startOffset, startNode, endNode;
                selChars = sel.toString();
                range = document.createRange();
                if (range.collapsed) {
                    startNode = sel.focusNode;
                    endNode = sel.anchorNode;
                    startOffset = sel.focusOffset;
                    endOffset = sel.anchorOffset;
                }
                else {
                    startNode = sel.anchorNode;
                    endNode = sel.focusNode;
                    startOffset = sel.anchorOffset;
                    endOffset = sel.focusOffset;
                }

                while (startOffset && !startNode.textContent.slice(startOffset - 1, startOffset).match(/[\s\n\t]/)) {
                    startOffset--;
                }
                while (endOffset < endNode.length && !endNode.textContent.slice(endOffset, endOffset + 1).match(/[\s\n\t]/)) {
                    endOffset++;
                }

                // here we get the nearest parent node which is common for the whole selection
                if (sel.rangeCount) {
                    parentEl = sel.getRangeAt(0).commonAncestorContainer.parentNode;
                    while (parentEl.textContent == sel.toString()) {
                        parentEl = parentEl.parentNode;
                    }
                }

                selWord = stringifyContent(sel.toString().trim());

                // this logic is for IE<10
                // } else if ((sel = document.selection) && sel.type != "Control") {
                //     var textRange = sel.createRange();
                //
                //      if (!textRange || textRange.text.length > maxContextLength) {
                //      return;
                //      }
                //
                //      if (textRange.text) {
                //      selChars = textRange.text;
                //      textRange.expand("word");
                //      // Move the end back to not include the word's trailing space(s), if necessary
                //      while (/\s$/.test(textRange.text)) {
                //      textRange.moveEnd("character", -1);
                //      }
                //      selWord = textRange.text;
                //      parentEl = textRange.parentNode;
                //      }

            }



            if (typeof parentEl == 'undefined') {
                return;
            }

            var selToFindInContext,
                contextsToCheck = { // different browsers implement different methods, we try them by turn
                    textContent: parentEl.textContent,
                    innerText: parentEl.innerText
                };

            textToHighlight = selWord;

            for (var method in contextsToCheck) {
                if (contextsToCheck.hasOwnProperty(method) && typeof contextsToCheck[method] != 'undefined') {

                    // start with counting selected word occurrences in context
                    var scope = {selection: 'word', context: 'initial'};
                    var context = stringifyContent(contextsToCheck[method].trim());
                    var selWithContext = stringifyContent(sel.toString().trim());
                    decoMistape.contextBuffer = context;
                    decoMistape.selBuffer = selWithContext;
                    var selPos; // this is what we are going to find
                    var selExactMatch = false;


                    if ((selPos = getExactSelPos(selWithContext, context)) != -1) {
                        selExactMatch = true;
                        selToFindInContext = selWithContext;
                        break;
                    }

                    // if there is more than one occurrence, extend the selection
                    selWithContext = getExtendedSelection(40);
                    scope.selection = 'word extended';

                    if ((selPos = getExactSelPos(selWithContext, context)) != -1) {
                        selExactMatch = true;
                        selToFindInContext = selWithContext;
                        break;
                    }

                    // if still have duplicates, extend the context and selection, and try again
                    var initialContext = context;
                    var extContext = getExtendedContext(context, parentEl, method);
                    context = extContext.contents;
                    selWithContext = getExtendedSelection(40, extContext.extensions);
                    scope.context = 'extended';

                    if ((selPos = getExactSelPos(selWithContext, context)) != -1) {
                        selExactMatch = true;
                        selToFindInContext = selWithContext;
                        break;
                    }

                    // skip to next context getting method and start over, or exit
                    if (!selWithContext) {
                        continue;
                    }

                    if (isSubstrUnique(selWord, selWithContext) || selWord == selChars.trim()) {
                        context = selWithContext;
                        selWithContext = selWord;
                        textToHighlight = selWord;
                        scope.selection = 'word';
                        scope.context = 'extended';
                    }
                    else {
                        context = selWord;
                        selWithContext = selChars.trim();
                        textToHighlight = selChars.trim();
                        scope.selection = 'initial';
                        scope.context = 'word';
                    }

                    selPos = context.indexOf(selWithContext);

                    if (selPos !== -1) {
                        selToFindInContext = selWithContext;
                    }
                    else if ((selPos = context.indexOf(selWord)) !== -1) {
                        selToFindInContext = selWord;
                    }
                    else if ((selPos = context.indexOf(selChars)) !== -1) {
                        selToFindInContext = selChars;
                    }
                    else {
                        continue;
                    }
                    break;
                }
            }

            if (selToFindInContext) {
                sel.removeAllRanges();
            }
            else {
                decoMistape.restoreInitSelection(sel, initialSel);
                return;
            }

            if (scope.context == 'extended') {
                context = extContext.extensions.left + initialContext + ' ' + extContext.extensions.right;
            }

            var contExcerptStartPos, contExcerptEndPos, selPosInContext, highlightedChars, previewText;
            maxContextLength = Math.min(context.length, maxContextLength);

            var truncatedContext = context;

            if (context.length > maxContextLength) {

                if (selPos + selToFindInContext.length / 2 < maxContextLength / 2) {
                    selPosInContext = 'beginning';
                    contExcerptStartPos = 0;
                    contExcerptEndPos = Math.max(selPos + selToFindInContext.length, context.indexOf(' ', maxContextLength - 10));
                }
                else if (selPos + selToFindInContext.length / 2 > context.length - maxContextLength / 2) {
                    selPosInContext = 'end';
                    contExcerptStartPos = Math.min(selPos, context.indexOf(' ', context.length - maxContextLength + 10));
                    contExcerptEndPos = context.length;
                }
                else {
                    selPosInContext = 'middle';
                    var centerPos = selPos + Math.round(selToFindInContext.length / 2);
                    contExcerptStartPos = Math.min(selPos, context.indexOf(' ', centerPos - maxContextLength / 2 - 10));
                    contExcerptEndPos = Math.max(selPos + selToFindInContext.length, context.indexOf(' ', centerPos + maxContextLength / 2 - 10));
                }

                truncatedContext = context.substring(contExcerptStartPos, contExcerptEndPos).trim();

                if (selPosInContext != 'beginning' && context.charAt(contExcerptStartPos - 1) != '.') {
                    truncatedContext = '... ' + truncatedContext;
                }
                if (selPosInContext != 'end' && context.charAt(contExcerptStartPos + contExcerptEndPos - 1) != '.') {
                    truncatedContext = truncatedContext + ' ...';
                }
            }

            if (isSubstrUnique(selChars, textToHighlight)) {
                highlightedChars = textToHighlight.replace(selChars, '<span class="mistape_mistake_inner">' + selChars + '</span>')
            }
            else {
                highlightedChars = '<strong class="mistape_mistake_inner">' + textToHighlight + '</strong>';
            }

            var selWithContextHighlighted = selToFindInContext.replace(textToHighlight, '<span class="mistape_mistake_outer">' + highlightedChars + '</span>');

            if (selExactMatch && truncatedContext == context) {
                previewText = truncatedContext.substring(0, selPos) + selWithContextHighlighted + truncatedContext.substring(selPos + selWithContext.length) || selWithContextHighlighted;
            }
            else {
                previewText = truncatedContext.replace(selWithContext, selWithContextHighlighted) || selWithContextHighlighted;
            }

            return {
                selection: selChars,
                word: selWord,
                replace_context: selToFindInContext,
                context: truncatedContext,
                preview_text: previewText,
                // post_id: decoMistape.getPostId()
            };
        },

        restoreInitSelection: function (sel, initialSel) {
            sel.collapse(initialSel.anchorNode, initialSel.anchorOffset);
            sel.extend(initialSel.focusNode, initialSel.focusOffset);
        }
    });

    $(document).ready(decoMistape.onReady);

})(jQuery);
/*eslint-enable */
